//? 73. Использование функций
//* - Функции которые мы передаем в компонент могут быть не только обработчиками событий - eventListener
//* - Можно передавать функции которые получают данные, для получения промиса
//* - Функция может инкапсулировать полученные данных (тогда компонент становиться независимым от источника данных)

//? 74. Render-функции
//* - Паттерн React - в компонент передается функция, которая рендерит часть компонента( или весь компонент)
// - renderItem={(item) => item.name}
//* - Такая функция обычно возвращает строку или React элементы
// - renderItem={(item) => <span>{item.name} <button>!</button></span>}

//? 75. Свойства-элементы
//* - В качестве значения свойства можно передавать React элемент
// <Card title={<h1>Hello</h1>}
//* - Так же можно создавать элементы контейнеры

//? 76. Children
//* - Компоненту можно передать одно из свойств, поместив его тело в элемент
//* - Это свойство доступно через props.children
//* - Поддерживает любые типы данных: элементы, функции, обьекты и примитивы

//? 77. Практика - рефакторинг компонента
//* - Вынесли детали получения данных и адреса картинки в отдельные функции
//* - В таком виде компонент может работать с разными объектами
//* - Остально решить, как сконфегурировать, какие именно данные будет отображать компонент

//? 78. Работа с props.children
//* - Компонент может решать, как именно использовать children
//* - Функция React.Children.map() упрощает обработку props.children
//* - Child элементы можно заменять, оборачивать в другие компоненты или скрывать(если вернуть null)
// React.Children.map(child => изменяем child)

//? 79. Клонирование элементов
//* - Реакт элементы нельзя изменять (они считатаются immutable)
//* - НО, можно создавать модифицированные копии при помощи React.cloneElement(что_копируем, { новый ключ: новое значение })
//* - К примеру, элементам можно добавлять новые свойства

//? 80. Компоненты высшего порядка (HOC)
//* - Функция которая возвращает компонент, который оборачивает основной компонент
//* - Компонент-обертка - верет на себя некоторые обязанности / логику о которых не нужно заботить внутреннему компоненту
//* - Компонент/функция-обертка - содержит переиспользумую логику которую хотелось бы скрыть или избежать ее постоянного копирования 

//? 81. Рефакторинг компонентов
//* - Обратная сторона "гибкости" компонентов это громозкая конфигурация
//* - Код будет более читабельным если вынести детали конфигурации в отдельные компоненты
//* - Для этого можно использовать НОС или просто написать компонент-обертку вручную

//? 82. Композиция компонентов высшегопорядка
//* - Композиция - применение одной функции к результатам другой
// const example = (x) => f(g(x)); sum = 5 => (2*(5 + 6))
//* - Компоненты высшего порядка это обычные функции, которые возвращают компоненты.
//* Композиция работает и для них.
//* - Так мы можем применять несколько "эффектов" HOC

//? 83. Контекст - часть 1
//* - Контекст решает проблему "глобальных данных"
//* - Вместо того чтобы передавать props через все слои приложения, данные можно передавать через контекс
//* - С помощью контекста мы можем сделать, чтобы компоненты не создавали объекты сервиса, а получали его

//? 84.Контекст - часть 2 - Использование Context API
//* - Создание контекста
// const { Provider, Consumer } = React.createService()

// Использование
//* Provider = Оборачивает часть приложения и передает контекст через value={Передаваемого Значение}
// <Provider value={Передаваемого Значение}>
// Тело компонентов для которых доступно {Передаваемого Значение}
//</Provider >

//* Consumer = Вызывает/получает переданный контекст через функцию
//<Consumer> {
// принимает функцию (Передаваемого Значение) => <Компонент нужно применить data={Передаваемого Значение} />
//}</Consumer >

//? 85. Использование HOC для работы с контекстом
//* - Обязанность получать данные из контекста можно вынести в компонент высшего порядка HOC + CONTEXT

//Todo повторить и написать без ошибки
//? 86. Трансформация props в компонентах высшего порядкаы
//* - НОС может преобразовывать свойства перед тем, как передать их компоненту
//* - Например: изменять их имена и выбирать, какие именно свойства нужно передать

//? 87. Обновление контекста
//* - Значение в контекст можно обновлять, как любое другое свойство компонента
//* - Компоненты должны изменения нужных свойств
//* - componentDidUpdate() - функция в которой можно проверить, какие свойства изменились

//? 90. Функция compose()
//* - Реализцуем композицию в виде функции
// compose = (...functions) => (component) => {
// return functions.reduceRight((wrapped, f) => f(wrapped), component);
//* Использование
// MyComp = compose(
//  withПоследняяФункция,
//  withСредняяФункция,
//  withПерваяФункцияВыполнения(параметр функции)
// )(Оборачиваемый компонент);

//? 91. Свойство defaultProps
//* - Позволяет устанавливать свойства по-умолчанию
// Componet.defaultProps = { ключ : значение }
//* Внутри класса можно использовать метод static
// static defaultProps = { ключ : значение }

//? 94. Библиотеки prop-types
//* - Библиотека props-types = набор стандартных функций валидаторов
// ItemList.propTypes = {
//   onItemSelected: PropTypes.func.isRequired,
//   data: PropTypes.arrayOf(PropTypes.object),
//   children: PropTypes.func.isRequired
//};
//* - Есть и другие библиотеки, с дополнительными валидаторами
// Например: airnbn-prop-types